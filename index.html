<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>LED Neon Control</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      background-color: #000;
    }

    #led-canvas {
      image-rendering: pixelated;
    }

    .orbitron-mono {
      font-family: 'Orbitron', monospace;
    }

    .neon-border {
      box-shadow:
        0 0 5px #0ff,
        0 0 10px #0ff,
        0 0 20px #0ff,
        0 0 40px #0ff,
        0 0 80px #0ff;
    }

    .neon-text {
      text-shadow:
        0 0 5px #fff,
        0 0 10px #0ff,
        0 0 20px #0ff,
        0 0 40px #0ff;
    }

    .danger-button {
      background: linear-gradient(to right, #ff0000, #cc0000);
      box-shadow: 0 0 10px #ff0000, 0 0 30px #ff0000, 0 0 50px #ff0000;
      color: white;
      font-weight: bold;
      border-radius: 1rem;
      padding: 1rem;
      transition: transform 0.2s ease;
    }

    .danger-button:hover {
      transform: scale(1.05);
      background: #ff1a1a;
    }

    .on-button {
      background: linear-gradient(to right, #0099ff, #0033cc);
      box-shadow: 0 0 10px #00ccff, 0 0 30px #00ccff, 0 0 50px #00ccff;
      color: white;
      font-weight: bold;
      border-radius: 1rem;
      padding: 1rem;
      transition: transform 0.2s ease;
    }

    .on-button:hover {
      transform: scale(1.05);
      background: #0077ff;
    }

    .effect-button {
      border: 2px solid #0ff;
      color: #0ff;
      background: transparent;
      padding: 0.75rem;
      border-radius: 0.75rem;
      font-weight: bold;
      text-shadow: 0 0 5px #0ff;
      transition: all 0.3s ease;
    }

    .effect-button:hover {
      background: #0ff;
      color: black;
      box-shadow: 0 0 20px #0ff, 0 0 40px #0ff;
    }

    input[type="range"] {
      accent-color: #00ffff;
    }

    .rainbow-bar {
      background: linear-gradient(to right, red, yellow, lime, cyan, blue);
    }

    .effect-stop-button {
      border-color: #f00 !important;
      color: #f00 !important;
    }
  </style>
</head>
<body class="text-white p-6 min-h-screen flex items-center justify-center">
  <div class="bg-black bg-opacity-70 p-8 rounded-3xl neon-border w-full max-w-3xl text-center">
    <h1 class="text-5xl font-bold neon-text mb-10">üåà LED Neon Control</h1>

    <!-- ALLES AN -->
    <button onclick="allOn()" class="on-button w-full mb-4 text-xl">
      üîµ ALLES AN
    </button>

    <!-- Farbwahl -->
    <div class="mb-10">
      <label class="block text-xl text-blue-300 mb-2">Farbe f√ºr ‚ÄûAlles An‚Äú</label>

      <!-- Regenbogen-Balken -->
      <div class="w-full h-4 rounded-lg mb-2 rainbow-bar"></div>

      <!-- Regler -->
      <input id="color-slider" type="range" min="0" max="100" value="0"
             class="w-full accent-blue-400" oninput="updateStaticColor(this.value)"
             title="Farbwahl f√ºr Alles An">
    </div>

    <!-- ALLES AUS -->
    <button onclick="turnOff()" class="danger-button w-full mb-10 text-xl">
      ‚ö†Ô∏è ALLES AUS
    </button>

    <!-- LAUFSCHRIFT -->
    <div class="mb-10 p-4 rounded-xl border-2 border-cyan-500 bg-black bg-opacity-50">
      <label class="block text-xl text-cyan-300 mb-3">üìú Laufschrift</label>
      <input id="scroll-text" type="text" placeholder="TEXT EINGEBEN..."
             class="w-full p-3 rounded-lg bg-gray-900 text-cyan-300 border-2 border-cyan-500 text-xl uppercase tracking-widest mb-3 orbitron-mono">
      <div class="flex gap-3">
        <button onclick="startScrollText()" class="effect-button flex-1 text-lg">
          ‚ñ∂Ô∏è Start
        </button>
        <button onclick="stopScrollText()" class="effect-button flex-1 text-lg effect-stop-button">
          ‚èπÔ∏è Stop
        </button>
      </div>
      <!-- Geschwindigkeit -->
      <div class="mt-3">
        <label class="block text-sm text-cyan-300 mb-1">Geschwindigkeit</label>
        <input id="scroll-speed" type="range" min="1" max="10" value="5" class="w-full" title="Geschwindigkeit der Laufschrift">
      </div>
      <!-- Farbe -->
      <div class="mt-3">
        <label class="block text-sm text-cyan-300 mb-1">Textfarbe</label>
        <div class="w-full h-3 rounded-lg mb-1 rainbow-bar"></div>
        <input id="scroll-color" type="range" min="0" max="100" value="50" class="w-full" title="Textfarbe f√ºr Laufschrift w√§hlen">
      </div>
    </div>

    <!-- WETTER -->
    <button onclick="showWeather()" class="w-full mb-4 p-4 rounded-xl border-2 border-yellow-400 bg-yellow-900 bg-opacity-30 text-yellow-300 text-xl font-bold hover:bg-yellow-800 transition-all">
      üå§Ô∏è WETTER ANZEIGEN
    </button>

    <!-- UHR -->
    <button onclick="showClock()" class="w-full mb-10 p-4 rounded-xl border-2 border-purple-400 bg-purple-900 bg-opacity-30 text-purple-300 text-xl font-bold hover:bg-purple-800 transition-all">
      üïê UHR ANZEIGEN
    </button>
    <p id="status-message" class="text-sm text-cyan-200 mb-10 block" style="min-height: 1.5rem;"></p>

    <!-- HELLIGKEIT -->
    <div class="mb-10">
      <label class="block text-xl text-cyan-300 mb-2">Helligkeit</label>
      <input type="range" min="0" max="9" value="5" class="w-full" oninput="updateBrightness(this.value)" title="Helligkeit einstellen">
    </div>

    <!-- EFFEKTE -->
  <!-- Effekte-Container -->
  <div id="effects-container" class="grid grid-cols-1 sm:grid-cols-3 gap-4"></div>

    <!-- LED VORSCHAU -->
    <div class="mt-10">
      <h2 class="text-2xl font-bold text-center text-cyan-300 mb-4">üîÆ LED Vorschau</h2>
      <div class="bg-black p-4 rounded-xl border-2 border-cyan-500">
        <canvas id="led-canvas" width="600" height="200" class="w-full"></canvas>
      </div>
    </div>

      <script>
        // 1. Array mit den kurzgef√ºhrten Effektnamen
        const effectTitles = [
          "rainbow",          // aus run_rainbow_effect
          "breathing",        // aus run_breathing_effect
          "sine_wave",        // aus run_sine_wave_effect
          "flash",            // aus run_flash_effect
          "diagnose",         // aus run_diagnose_effect
          "clock",            // aus run_clock_effect
          "raupe",            // aus run_rainbow_caterpillar
          "rainbow_wave"      // aus run_rainbow_wave_effect
        ];

        // 2. Buttons generieren
        const container = document.getElementById('effects-container');
        container.innerHTML = effectTitles
          .map((title, i) => `
            <button onclick="triggerEffect(${i})" class="effect-button">
              ${title}
            </button>
          `)
          .join('');
      </script>
  </div>

  <script>
    let hueTimeout;
    const statusEl = document.getElementById('status-message');

    function setStatus(message, tone = 'info') {
      if (!statusEl) return;
      const color = tone === 'error' ? 'text-red-400' : 'text-cyan-200';
      statusEl.className = `text-sm mb-10 block ${color}`;
      statusEl.style.minHeight = '1.5rem';
      statusEl.textContent = message || '';
    }

    function showWeather() {
      setStatus('Wetter wird geladen ...');
      fetch('/test_weather', { method: 'POST' })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            setStatus(`Wetter geladen: ${data.text}`);
          } else {
            setStatus(`Fehler: ${data.text || 'Keine Daten'}`, 'error');
          }
        })
        .catch(() => setStatus('Fehler: Wetterdienst nicht erreichbar', 'error'));
    }

    function showClock() {
      fetch('/effect/5', { method: 'POST' })
        .then(() => setStatus('Uhr gestartet'))
        .catch(() => setStatus('Fehler beim Start der Uhr', 'error'));
    }

    function startScrollText() {
      const text = document.getElementById('scroll-text').value.toUpperCase();
      const speed = document.getElementById('scroll-speed').value;
      const colorVal = document.getElementById('scroll-color').value;
      const hue = (colorVal / 100) * 0.66;
      
      if (!text.trim()) {
        alert('Bitte Text eingeben!');
        return;
      }
      
      fetch('/scrolltext', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: text, speed: parseInt(speed), hue: hue })
      });
    }

    function stopScrollText() {
      fetch('/off', { method: 'POST' });
    }

    function updateBrightness(level) {
      fetch('/brightness', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ value: level / 9 })
      });
    }

    function turnOff() {
      fetch('/off', { method: 'POST' });
    }

    function allOn() {
      const slider = document.querySelector('#color-slider');
      const hue = (slider.value / 100) * 0.66;
      fetch('/static_color', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hue })
      }).then(() => {
        fetch('/static_on', { method: 'POST' });
      });
    }

    function triggerEffect(index) {
      fetch(`/effect/${index}`, { method: 'POST' });
    }

    function updateStaticColor(val) {
      const hue = (val / 100) * 0.66;

      // Farbwert ans Backend senden
      fetch('/static_color', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hue })
      });

      // Nur wenn nicht schon im statischen Modus ‚Üí LEDs setzen (mit Verz√∂gerung)
      clearTimeout(hueTimeout);
      hueTimeout = setTimeout(() => {
        fetch('/static_on', { method: 'POST' });
      }, 200); // 200 ms Pause nach dem letzten Schiebeschritt
    }

    // LED Vorschau Canvas
    const canvas = document.getElementById('led-canvas');
    const ctx = canvas.getContext('2d');
    const PANEL_WIDTH = 30;
    const PANEL_HEIGHT = 10;
    const LED_SIZE = canvas.width / PANEL_WIDTH;

    function drawLEDs(ledData) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let x = 0; x < PANEL_WIDTH; x++) {
        for (let y = 0; y < PANEL_HEIGHT; y++) {
          // Snake-Pattern Mapping (wie im Backend)
          const index = x * PANEL_HEIGHT + (x % 2 === 0 ? y : (PANEL_HEIGHT - 1 - y));
          const color = ledData[index] || [0, 0, 0];

          // Canvas-Rendering: 180¬∞ Drehung + Y-Flip (entspricht Panel-Ausrichtung)
          const flippedX = PANEL_WIDTH - 1 - x;
          const flippedY = PANEL_HEIGHT - 1 - y;

          ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
          ctx.fillRect(flippedX * LED_SIZE, flippedY * LED_SIZE, LED_SIZE - 1, LED_SIZE - 1);
        }
      }
    }

    // LED-Updates via Polling (alle 100ms)
    setInterval(() => {
      fetch('/led_status')
        .then(res => res.json())
        .then(data => {
          if (data.leds) {
            drawLEDs(data.leds);
          }
        })
        .catch(() => {}); // Fehler ignorieren
    }, 100);

    // Initial schwarzes Display
    drawLEDs(Array(300).fill([0, 0, 0]));

  </script>
</body>
</html>
